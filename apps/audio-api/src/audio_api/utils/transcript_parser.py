import re
from typing import List
from audio_api.models.audio import TranscriptSegment


def parse_transcript_from_text(raw_text: str) -> List[TranscriptSegment]:
    segments = []

    # Regex logic:
    # 1. \[\s*(\d{1,2}):(\d{2})\s*\] : Tìm timestamp [MM:SS] (cho phép khoảng trắng thừa)
    # 2. \s* : Khoảng trắng
    # 3. (?:(.*?):\s*)? : (Option) Tìm tên Speaker kết thúc bằng dấu hai chấm (VD: "Speaker A: ")
    # 4. (.*?) : Nội dung text
    # 5. (?=\[\s*\d{1,2}:\d{2}\s*\]|$) : Dừng lại khi gặp timestamp tiếp theo hoặc hết chuỗi

    pattern = re.compile(
        r'\[\s*(\d{1,2}):(\d{2})\s*\]\s*(?:(.*?):\s*)?(.*?)(?=\[\s*\d{1,2}:\d{2}\s*\]|$)',
        re.DOTALL
    )

    matches = pattern.findall(raw_text)

    for i, match in enumerate(matches):
        minutes, seconds, speaker_candidate, content = match

        # Tính toán giây bắt đầu
        start_seconds = int(minutes) * 60 + int(seconds)

        # Xử lý nội dung
        text = content.strip()
        speaker = speaker_candidate.strip() if speaker_candidate else "Unknown"

        # Bỏ qua các dòng tiêu đề rác nếu có
        if "TRANSCRIPT:" in text or "Generated by" in text:
            continue

        segments.append(TranscriptSegment(
            start=float(start_seconds),
            end=0.0,  # Sẽ tính toán lại bên dưới
            speaker=speaker,
            text=text
        ))

    # Tính toán thời gian kết thúc (end time) dựa trên đoạn tiếp theo
    for i in range(len(segments) - 1):
        segments[i].end = segments[i + 1].start

    # Đoạn cuối cùng mặc định cộng thêm 2s hoặc giữ nguyên start nếu ngắn
    if segments:
        segments[-1].end = segments[-1].start + 2.0

    return segments